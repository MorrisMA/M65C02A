The M65C02A has greatly extended the capabilities of the 6502/65C02 processors
to support HLLs like Pascal and C. One of the ways this has been accomplished
has been by enabling BP-relative and SP-relative addressing modes.

BP-relative enables the use of a stack frame by allowing subroutine parameters
to be accessed using positive offsets from the Base Pointer (BP), i.e. the X
register, and local variables as negative offsets from the BP. To accomplish
this, if the value of X is greater than 512, i.e. the stack is not in page 1 or
page 0 and limited by default to 256 bytes, then the zp parameter is automatic-
ally treated as a signed offset relative to X for any zp,X or (zp,X) addressing
mode instructions by the M65C02A address generator. (Note: there is no need for
this specialized treatment of the offset for the abs,X and (abs,X) addressing
modes since a 16-bit offset can be naturally considered as signed.)

The SP-relative addressing mode uses only unsigned offsets. Data pushed onto the
stack is accessed using SP-relative unsigned offsets.

The recursive descent compiler is fairly simple and it's parsing of expressions
proceeds from left to right. As a consequence, the left operand of any two
operand expression is pushed onto the stack first and the right operand follows.
When evaluating the expression, the right operand is pulled from the stack into
the accumulator first.

For all dual operand operations except subtraction, the order of the operands is
not significant, but the operand order is significant for subtraction and com-
pare instructions. To configure the expression operands in the correct order for
subtraction or comparison instructions, the M65C02A Pascal compiler currently
exchanges the right operand in the accumulator with the left operand on the
stack, and then the subtraction / compare instruction subtracts the right oper-
and on the stack from the left operand in the accumulator. 

This instruction sequence, required to properly deal with the required order of
operands for subtraction / comparison operations, makes subtractions more expen-
sive than additions. The following is the instruction sequence needed to perform
subtractions using operands on the stack:

        pla.w       ; (4) Pull right operand from stack
        xma.w 1,S   ; (7) Exchange right and left operands, put right on stack
        sec         ; (1) Initialize C for subtraction
        sbc.w 1,S   ; (5) subtract: left - right,  A <= A - (1,S)
        adj #2      ; (2) adjust S, remove right operand from stack
        
Thus, subtraction requires an additional 7 cycles, i.e. the xma.w 1,S instruc-
tion. In addition, the adj #2 instruction is required because the right operand
remains on the stack after the subtraction is complete.

A simple change can be implemented to the M65C02A's SP-relative addressing mode
that can reduce the number of clock cycles and instructions needed to correctly
implement stack-based subtraction, and evaluation of stack-based expressions.
That is, change subtraction using the SP-relative addressing mode so that the
the order of the operands into the ALU is reversed. In other words, the accumu-
lator is treated as the right operand and the value on the stack is treated as
the left operand. If this change is made, then the previous instruction sequence
for subtraction becomes the same as that required for any other dual operand ALU
stack-based expression evaluation operations:

        pla.w       ; (4) pull right operand from stack
        sec         ; (1) initialize C for subtraction
        sbc.w 1,S   ; (5) execute subtraction: A <= (1,S) - A
        adj #2      ; (2) adjust S, remove right operand from stack
             
This sequence, or similar operations, performs 16-bit stack-based expression
evaluations in 12 clock cycles instead of the 19 clock cycles previously needed.
That is roughly a 37% performance improvement without any other optimizations
for subtraction or comparison instructions.

As a first alternative, a new set of instructions in Column 3 can be defined
which are optimized to perform ALU operations based on the stack-based model
used by HLLs like C and Pascal. One approach would be to create instructions
that use A and Y as working registers, and that perform ALU operations using
registers A, Y as the right and left operands, respectively. For example, if the
operands as found on the stack, then the following instruction sequence can
replace those above:

        pla.w       ; (4) pull right operand from stack into A
        psya.w      ; (4) pull left operand from stack into Y, A <= Y + ~A + 1
        
This set of instructions can significantly reduce the number of cycles required
to perform the required ALU operations for arguments passed on the stack. As
shown in the preceding instruction sequence, the number of cycles required to
subtract two values found on the evaluation stack is reduced from 19 to 8. The
reduction in the number of cycles is due to the reduction of the number of 
operations to essentially two 16-bit evaluation stack pops. The definition of
the subtraction operation performed was changed in the preceding instruction
sequence so that the normally required sec instruction was not required. The
definition of the subtraction operation could be preserved so that the sec
instruction is required. The additional clock cycle would not decrease the sav-
ings that are apparent with these instructions: 19 versus 9 instead of 19 vs. 8.
In either case, the overall decrease in the number of cycles required is signi-
ficant, either 53% or 58%, respectively.

A second alternative, a new set of instuctions can be defined in Column 3 that
use the register stack for the two operands: NOS - right operand, and TOS - left
operand. In this way, the register stack is used for both operands as is natural
for such a structure, and the order of the operands on the external and the in-
ternal stacks is maintained in the natural order of the recursive descent compi-
ler. The instruction sequence required would be the same as in the previous 
example except that the second instruction would use TOS and NOS of the A regis-
ter stack instead of the TOS registers of both the A and Y register stacks:

        pla.w       ; (4) pull right operand from external stack into ATOS
        psub.w      ; (4) push ATOS to ANOS, pull left operand from ext. stack
                    ;     into ATOS, and ATOS <= ATOS - ANOS, ANOS <= ABOS
        
Like the previous set of istructions, this approach maximizes the utility of the
existing A register stack resources without altering the contents of another
register stack. The operand evaluation order of the instructions, relative to
the operands on the external stack does not change, which is a benefit from the
compiler's perspective. Except in those rare instances where all three register
stack registers are being used, this approach automatically restores the NOS
register contents from the BOS register. In those cases where three registers
of the register stack are used, the BOS would be lost unless previously saved, 
or the register stack is extended with one more register into which the BOS is
saved and restored from. Finally, the overall cost of the substraction operation
is reduced by either 53% or 58%, depending on whether the SEC instruction is 
required by the definition of these new  subtraction / addition instructions.