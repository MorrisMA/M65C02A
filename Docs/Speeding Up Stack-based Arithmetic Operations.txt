The M65C02A has greatly extended the capabilities of the 6502/65C02 processors
to support HLLs like Pascal and C. One of the ways this has been accomplished
has been by enabling BP-relative and SP-relative addressing modes.

BP-relative enables the use of a stack frame by allowing subroutine parameters
to be accessed using positive offsets from the Base Pointer (BP), i.e. the X
register, and local variables as negative offsets from the BP. To accomplish
this, if the value of X is greater than 512, i.e. the stack is not in page 1 and
limited by default to 256 bytes, then the zp parameter is automatically treated
as a signed offset relative to X for any zp,X or (zp,X) addressing mode instruc-
tions by the M65C02A address generator. (Note: there is no need for this
specialized treatment of the offset for the abs,X and (abs,X) addressing modes
since a 16-bit offset can be naturally considered as signed.)

The SP-relative addressing mode uses only unsigned offsets. Data pushed onto the
stack is accessed using SP-relative offsets. The recursive descent compiler is
fairly simple and its parsing of expressions proceeds from left to right. As a
consequence, the left operand of any two operand expression is pushed onto the 
stack first and the right operand follows. When evaluating the expression, the
right operand is pulled from the stack into the accumulator first. For all dual 
operand operations except subtraction, the order of the operands is not signi-
ficant, but the operand order is significant for subtraction and compare ins-
tructions. To configure the expression operands in the correct order for sub-
traction or comparison instructions, the M65C02A currently exchanges the right
operand in the accumulator with the left operand on the stack, and then the
subtraction / compare instruction subtracts the right operand on the stack from
the left operand in the accumulator. 

This instruction sequence, required to properly deal with the required order of
operands for subtraction / comparison operations, makes subtractions more expen-
sive than additions. The following is the instruction sequence needed to perform
subtractions using operands on the stack:

        pla.w       ; (4) Pull right operand from stack
        xma.w 1,S   ; (7) Exchange right and left operands, put right on stack
        sec         ; (1) Initialize C for subtraction
        sbc.w 1,S   ; (5) subtract: left - right,  A <= A - (1,S)
        adj #2      ; (2) adjust S, remove right operand from stack
        
Thus, subtraction requires an additional 7 cycles, i.e. the xma.w 1,S instruc-
tion. In addition, the adj #2 instruction is required because the right operand
remains on the stack after the subtraction is complete.

A simple change can be implemented to the M65C02A's SP-relative addressing mode
that can reduce the number of clock cycles and instructions needed to correctly
implement stack-based subtraction, and evaluation of stack-based expressions.
That is, change subtraction using the SP-relative addressing mode so that the
the order of the operands into the ALU is reversed. In other words, the accumu-
lator is treated as the right operand and the value on the stack is treated as
the left operand. If this change is made, then the previous instruction sequence
for subtraction becomes the same as that required for any other dual operand ALU
stack-based expression evaluation operations:

        pla.w       ; (4) pull right operand from stack
        sec         ; (1) initialize C for subtraction
        sbc.w 1,S   ; (5) execute subtraction: A <= (1,S) - A
        adj #2      ; (2) adjust S, remove right operand from stack
             
This sequence, or similar operations, performs 16-bit stack-based expression
evaluations in 12 clock cycles instead of the 19 clock cycles previously needed.
That is roughly a 37% performance improvement without any other optimizations
for subtraction or comparison instructions.