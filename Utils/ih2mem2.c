/*******************************************************************************
********************************************************************************
////////////////////////////////////////////////////////////////////////////////
//
//  Copyright 2014 by Michael A. Morris, dba M. A. Morris & Associates
//
//  All rights reserved. The source code contained herein is publicly released
//  under the terms and conditions of the GNU Lesser Public License. No part of
//  this source code may be reproduced or transmitted in any form or by any
//  means, electronic or mechanical, including photocopying, recording, or any
//  information storage and retrieval system in violation of the license under
//  which the source code is released.
//
//  The source code contained herein is free; it may be redistributed and/or
//  modified in accordance with the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either version 2.1 of
//  the GNU Lesser General Public License, or any later version.
//
//  The source code contained herein is freely released WITHOUT ANY WARRANTY;
//  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
//  PARTICULAR PURPOSE. (Refer to the GNU Lesser General Public License for
//  more details.)
//
//  A copy of the GNU Lesser General Public License should have been received
//  along with the source code contained herein; if not, a copy can be obtained
//  by writing to:
//
//  Free Software Foundation, Inc.
//  51 Franklin Street, Fifth Floor
//  Boston, MA  02110-1301 USA
//
//  Further, no use of this source code is permitted in any form or means
//  without inclusion of this banner prominently in any derived works.
//
//  Michael A. Morris
//  Huntsville, AL
//
////////////////////////////////////////////////////////////////////////////////
********************************************************************************
*******************************************************************************/

/*******************************************************************************
********************************************************************************

This utility is designed to function as a filter program to translate an Intel
Hex programming file into a MEM file compatible with Xilinx's Data2MEM utility
program.

It expects an Intel Hex file generated by an assembler to be piped in on stdin,
and it outputs its MEM-compatible output on stdout.

********************************************************************************
Revision History

    1.00    14L11   MAM     Initial File Creation

********************************************************************************
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int ahtoi(char ch)
{
    int tmp;

    tmp = toupper(ch);

    tmp = (ch - '0');
    if(tmp > 9) tmp = (tmp - 7);

    return tmp;
}

void main(void)
{
    char ch;
    int  i = 0;
    int  j = 0;
    char state = 0;

    int  rlen = 0;
    int  radd = 0;
    int  rtyp = 0;
    char rdat[4];

    while(!feof(stdin)) {

        ch = fgetc(stdin);
        i += 1;
        
//        printf("S:%01d; cnt: %4d; rlen: %4d; ch: 0x%02X [%c]\n", 
//            state, i, rlen, ch, ((ch < 32) ? ' ' : ch));

        switch(state) {
           case 0 :                     // Find start of record

                if(ch == ':') {         // Read record length - 2 chars
                     i = 0;
                     j = 0;
                     rlen  = 0;
                     state = 1;
                }

                break;

           case 1 :                     // Read and convert record length field

                rlen = (rlen << 4) + ahtoi(ch);

                if(i == 2) {            // Capture record address field
                     i = 0;
                     j = 0;
                     
                     radd  = 0;
                     state = 2;
                }

                break;

           case 2 :                     // Read and convert record address field

                radd = (radd << 4) + ahtoi(ch);

                j += 1;

                if(i == 4) {            // Read record type
                     i = 0;             // read two (2) chars
                     j = 0;

                     rtyp  = 0;
                     state = 3;
                }

                break;

           case 3 :                     // Read and convert record type

                rtyp = (rtyp << 4) + ahtoi(ch); // Convert to integer

                if(i == 2) {            // ((rtype) ? 0 : 4)
                     if(rtyp == 0) {    // Read and print data records
                         fprintf(stdout, "@%04X\n", radd);  // emit address with padding
                         
                         i = 0;
                         j = 0;

                         state = 4;
                         
                     } else {           // Skip to next record or EOF
                         i = 0;
                         j = 0;

                         state = 0;
                     }
                }

                break;

           case 4 :                     // Read and output sorted data - 2 chars

                rdat[j] = ch;

                j += 1;

                if(i == 2) {
                     i = 0;
                     j = 0;

                     fprintf(stdout, "%c%c\n", rdat[0], rdat[1]);

                     rlen -= 1;      // Decrement record length

                     if(rlen == 0) {
                         state = 0;  // End of data, skip to next record/EOF
                     } else {
                         state = 4;  // Data available, read next data word
                     }

                }

                break;

           default : break;
        }
    }
}