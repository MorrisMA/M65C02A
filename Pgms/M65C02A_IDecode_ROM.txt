header
Project: M65C02A_IDecode_ROMa
File Revision: 0021
Author(s): Michael A. Morris
Description: M65C02A Instruction Decoder - HLL-optimized Instruction Set
endh

--------------------------------------------------------------------------------
--
--  Copyright 2015-2016 by Michael A. Morris, dba M. A. Morris & Associates
--
--  All rights reserved. The source code contained herein is publicly released
--  under the terms and conditions of the GNU General Public License as conveyed
--  in the license provided below.
--
--  This program is free software: you can redistribute it and/or modify it
--  under the terms of the GNU General Public License as published by the Free
--  Software Foundation, either version 3 of the License, or any later version.
--
--  This program is distributed in the hope that it will be useful, but WITHOUT
--  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
--  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
--  more details.
--
--  You should have received a copy of the GNU General Public License along with
--  this program.  If not, see <http://www.gnu.org/licenses/>, or write to
--
--  Free Software Foundation, Inc.
--  51 Franklin Street, Fifth Floor
--  Boston, MA  02110-1301 USA
--
--  Further, no use of this source code is permitted in any form or means
--  without inclusion of this banner prominently in any derived works.
--
--  Michael A. Morris <morrisma_at_mchsi_dot_com>
--  164 Raleigh Way
--  Huntsville, AL 35811
--  USA
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Revision History:
--------------------------------------------------------------------------------
--
--  0001    15A03   MAM     Initial release.
--
--  0002    15G04   MAM     Updated to support LDA @IP+off and MOV instructions
--
--  0003    15G06   MAM     Modified code for CMP/CPX/CPY instructions in order
--                          to indicate that CMP/CPX/CPY is being executed. In
--                          the 16-bit mode, this indicator will be used by the
--                          ALU logic to change the condition code field from
--                          one that sets NZC to one that sets all four: NVZC.
--                          This will allow the M65C02A to support signed compa-
--                          risons and allow conditional branches to branch on
--                          signed and unsigned multi-flag tests.
--
--  0004    15G12   MAM     Restored BRK mode, and implemented MOV as a SPC1
--                          instruction using Opcode[5].
--
--  0005    15G31   MAM     Changed the RTI CCSel code from PSW to BRK. This is
--                          used in the PSW logic to update the K bit only when
--                          an RTI instruction is being performed. Thus, the
--                          processor mode can only be changed from kernel to
--                          user mode using a stack frame pulled from the stack
--                          using an RTI instruction.
--
--  0006    15H02   MAM     Modified definition of RTI from VAL to SPC1 in order
--                          to support change that will enable RTI to be used
--                          swap from kernel to user mode at the conclusion of
--                          the RTI instruction, i.e. on the fetch of the first
--                          instruction following the ISR or the first instruc-
--                          tion of a user mode process.
--
--  0007    15H03   MAM     Removed WS_P from the BRK instruction. With change
--                          made in 0006, this write selection became redundant.
--
--  0008    15K12   MAM     Added signal XRSP as part of the FORTH VM so that X
--                          is used for the stack when ENT/PHI/PLI instructions
--                          are used and OSX is not set. When OSX and XRSP are
--                          both set, the system stack will be used. This
--                          feature can be enabled or disabled by the microcode
--                          defined in this file.
--
--  0009    15K13   MAM     Changed the assigned opcode for MOV from $44 to $42.
--                          Assigned the unused opcode at $44 to STA ip,I++ to
--                          match the LDA ip,I++ opcode at $54. The new instruc-
--                          tion uses the same addressing mode as LDA ip,I++,
--                          but stores the accumulator at the address specified
--                          by IP and autoincrements IP. IND, SIZ, and ISZ pre-
--                          fix instructions may be applied with the expected
--                          indirection and size effects.
--
--  0010    15K25   MAM     Moved the JMP ip,I++ from $82 to $DC, replacing the
--                          BSR rel16 instruction. BSR rel16 can be synthesized
--                          using PSH #imm16; BRL rel16; with only a four cycle
--                          penalty. Added ADC ip,I++ as $82. This instruction
--                          expected to be used for computing IP-relative jumps
--                          and branches.
--
--  0011    15L10   MAM     Replaced the JMP ip,I++ instruction because NXT
--                          faster and shorter. JMP ip,I++ replaced with an
--                          instruction to adjust the system stack pointer. The
--                          ADJ #imm16 add (w/o carry) the signed 16-bit imme-
--                          diate value to Sk/Su. If OSX is asserted, the 16-
--                          bit value is added to the X register. Modified the
--                          ADC ip,I++ instruction to add without carry:
--                          ADD ip,I++. This shortens the IP-relative branches
--                          and jumps by one byte and one cycle.
--
--  0012    15L19   MAM     Modified ADJ instruction so it uses the Y register
--                          instead of an immediate operand to adjust the system
--                          or auxiliary stack pointers.
--
--  0013    15L30   MAM     Removed WRD flag for DUP, SWP, and ROT instructions.
--
--  0014    15L31   MAM     Replaced the Rockwell bit-oriented instructions in
--                          columns 7 and F with another set of instructions
--                          intended to provide better stack-oriented processing
--                          and to more fully support threaded code compilers
--                          and interpreters. In column 7, the even entries are
--                          duplicates of the corresponding entries in column 3.
--                          Instead of BP-relative, the addressing mode is SP-
--                          relative by default. (Prefixing with OSX results in
--                          same instruction from column 3 and vice-versa. This
--                          modification is being made as a consequence of the
--                          high use of SP-relative operations in the Pascal
--                          compiler being targetted to the core.) The odd ele-
--                          ments of column 7 implement BP-relative versions of
--                          a number of RMW instructions: ASL/ROL/LSR/ROR,
--                          TSB/TRB, and DEC/INC. (While porting the Pascal com-
--                          piler it was determined that incrementing/decrement-
--                          ing array indices is a frequent requirement. Since
--                          there is no BP-relative addressing mode for the DEC/
--                          INC instructions, modifying the array index varia-
--                          bles on the stack required some significant calcula-
--                          tions. Given the support for nested procedures and
--                          functions in Pascal, the majority of array opera-
--                          tions are in procedures and functions which means
--                          that the majority of array index variables are on
--                          the stack. Only array indices defined at the root
--                          level can use the DEC/INC abs instructions of the
--                          core. All other array indices must be manipulated
--                          using loads, register DEC/INC, and stores. Although
--                          this is a straightforward instruction sequence, the
--                          number of cycles required to perform this frequent
--                          operation indicates that the M65C02A instruction set
--                          needed to be modified and the Rockwell instructions
--                          were the best instructions to replace since they are
--                          not used at all by the compiler, and seldom used by
--                          assembly language programmers.) Column F is devoted
--                          to IP-relative (w/ autoincrement) instructions. The
--                          set of instructions selected are those represented
--                          in column 7 except that the addressing mode has been
--                          changed. In addition, the ADC/SBC instructions are
--                          modified to be ADD/SUB, so that CLC/SEC are not re-
--                          quired. Extended precision arithmetic is supported
--                          by the standard 6502/65C02 instruction set.
--
--  0015    16A05   MAM     Converted ADC/SBC sp,S to RMW where the left operand
--                          is M and the right operand is A, and the result is
--                          written back to M. This is expected to improve the
--                          HLL performance of the core by operating directly on
--                          local variables found on the system stack either in
--                          function/procedure stack frame (relative to BP) or
--                          in dynamically created variables used for expression
--                          evaluation. Replaced BRL rel16 with XMA sp,S. XMA
--                          exchanges the accumulator with the addressed stack
--                          element.
--
--  0016    16D09   MAM     Rearranged instruction table to match M65C02B sheet.
--                          New arrangement attempts to normalize the instruc-
--                          tion length to that of the original 6502/65C02 co-
--                          lumn in which the new instruction is placed. IOW,
--                          the new single byte instructions are placed in a co-
--                          lumn which is composed of single byte instructions
--                          of the original 6502/65C02. New two/three byte
--                          instructions are placed in columns in which the ori-
--                          ginal 6502/65C02 two/three byte instructions were
--                          defined.
--
--  0017    16D10   MAM     Modified the Mode fields to add support for several
--                          special instructions enabled by the IND prefix. The
--                          dedicated ADJ mode was converted to SPC2, and the
--                          ADJ instruction included in the decode space created
--                          by the change. In addition, with IND prefixed to the
--                          ASL/ROL A instructions, an arithmetic left shift
--                          that sets the V flag was enabled. With IND prefixed
--                          to the LSR instruction, an arithmetic right shift
--                          instruction was enabled by shifting Q[7] instead of
--                          a logic zero. Finally, when prefixed by IND, the
--                          INC/DEC A instructions will now set the C flag.
--
--  0018    16I27   MAM     Modified the decode table to match that in the uPgm.
--                          Implemented the ADJ #imm instruction, and added NZ
--                          CCSel code to the PUL zp, PUL abs instructions.
--
--  0019    16K12   MAM     Modified the decode table to match the latest defi-
--                          nition provided in the Excel spreadsheet. Changed
--                          the implementation of the PSH/PUL zp/abs/#imm
--                          instructions to require the SIZ prefix instruction
--                          in order to perform 16-bit push/pull operations.
--                          Modified CCSel control field for the ADJ #imm
--                          instruction to NUL so that the flags in PSW are not
--                          affected.
--
--  0020    16L05   MAM     Restructured the instruction decoder to match the
--                          Excel spreadsheet. Column 7 & 15 restored to decode
--                          Rockwell bit-oriented instructions. Column 3 imple-
--                          ments the FORTH-oriented IP++ instructions. MOV #imm
--                          moved from $82 to $54, and $22, $42, $62 and $82 are
--                          reserved for future use. The WDC 65C02S instructions
--                          WAI and STP have been replaced with two new prefix
--                          instructions: OSZ and OIS. OSZ combines OSX and SIZ.
--                          OIS combines OSX, IND, and SIZ. The prefix instruc-
--                          tions have been reorganized into a group of eight
--                          instructions: $8B - OAY, $9B - IND, $AB - SIZ, $BB -
--                          ISZ, $CB - OAX, $DB - OSX, $EB - OSZ, $FB - OIS.
--
--  0021    17A01   MAM     The prefix instructions have been restored into a
--                          group of eight instructions: $8B - OSX, $9B - IND,
--                          $AB - SIZ, $BB - ISZ, $CB - OSX, $DB - OSZ, $EB -
--                          OAX, and $FB - OAY. This allows WAI ($CB) and STP
--                          ($DB) to be restored if W65C02S compatibility is 
--                          needed.
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Mode Field
--------------------------------------------------------------------------------

VAL     .asm    0   -- Valid Instruction (not otherwise decoded)
SPC2    .asm    1   -- Special 2 Instructions  (See table below             )
COP     .asm    2   -- COP Instruction  (CO-Processor instruction           )
BRK     .asm    3   -- BRK Instruction
FTH     .asm    4   -- FORTH VM Instructions
SPC1    .asm    5   -- Special 1 Instructions  (See table below             )
PFX     .asm    6   -- Prefix Instructions   (See table below               )
--WAI     .asm    7   -- WAI Instruction  (WAit for Interrupt                 )
--
--  One-hot encoding of the Opcode field for SPC1 mode instructions
--
--  {PSH, PHR, MOV, RTI, DUP, SWP, ROT, WRD}
--
--  PSH - Push Instructions         (PSH zp/abs/#imm; PHA/PHX/PHY           )
--  PHR - PHR Instruction           (PHR rel16                              )
--  MOV - MOV Instruction
--  RTI - RTI Instruction
--  DUP - Register Stack DUPlicate  (16-bit only                            )
--  SWP - Register Stack SWaP       (16-bit only                            )
--  ROT - Register Stack ROTate     (16-bit only                            )
--  WRD - Set 16-bit op size        (16-bit only                            )
--
--  One-hot encoding of the Opcode field for SPC2 mode instructions
--
--  {ADJ, Rsvd[6:3], ASR, CEN, VEN}
--
--  ADJ - Adjust S: S <= S + {OP2, OP1}
--
--  ASR - Enable Arithmetic Right Shift using LSR A: C_In <= Q[7]
--  CEN - Enable Carry for INC/DEC A
--  VEN - Enable V for ASL/ROL A
--
--  One-hot encoding of the Opcode field for PFX mode instructions
--
--  {3'b0, iOSX, iOAY, iOAX, iSIZ, iIND}
--
--  iOSX - OSX Instruction          (Override S with X                      )
--  iOAY - OAY Instruction          (Override A with Y                      )
--  iOAX - OAX Instruction          (Override A with X                      )
--  iSIZ - SIZ | ISZ Instructions   (Override Operand size: 8 => 16         )
--  iIND - IND | ISZ Instructions   (Direct address => indirect address     )
--
--  One-hot encoding of the Opcode field for FORTH VM mode instructions
--
--  {NXT, ENT, PHI, PLI, XRSP, 2'b0, INI}
--
--  NXT  - FORTH VM NEXT
--  ENT  - FORTH VM ENTER (DOCOLON)
--  PHI  - FORTH VM Push IP/W => PS/RS
--  PLI  - FORTH VM Pull IP/W <= PS/RS
--  XRSP - FORTH VM Use X for Return Stack Pointer (RSP) ENT/PHI/PLI (OSX == 0)
--  INI  - FORTH VM Increment IP/W
--
--------------------------------------------------------------------------------
-- ROM ( output ) Field definitions
--------------------------------------------------------------------------------

Mode    .def    3   -- Instruction Class or Specific Instruction
RMW     .def    1   -- Read-Modify-Write Instruction Type Field
FU_Sel  .def    6   -- ALU Functional Unit Select (one-hot)
ALU_OP  .def    2   -- ALU Operation
QSel    .def    2   -- ALU Q Operand Select
RSel    .def    2   -- ALU R Operand Select
CSel    .def    2   -- ALU Arithmetic Unit Carry Input Select
WSel    .def    3   -- ALU Register Write Select
OSel    .def    3   -- ALU Register Output Select
CCSel   .def    4   -- ALU Condition Code Operation
Opcode  .def    8   -- Instruction Opcode, bit mask, etc.

--------------------------------------------------------------------------------
--  Constant definitions
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--  ALU Functional Unit Select definitions

LST     .equ    48  -- Select Load/Store/Transfer Functional Unit
LU      .equ    40  -- Select Logic Unit (AND/ORA/EOR, BIT/TRB/TSB,
                    --                    RMB/SMB/BBR/BBS,
                    --                    SEC/CLC/SEI/CLI/SED/CLD/CLV
SU      .equ    36  -- Select Shift/Rotate Unit (ASL/ROL/LSR/ROR)
ADD     .equ    34  -- Select Decimal/Binary Adder (ADC/SBC, ADD/SUB, ADJ)
IDC     .equ    33  -- Select Bin. Add (INC/DEC/CMP/INX/DEX/CPX/INY/DEY/CPY)

--------------------------------------------------------------------------------
--  General Definitions
--------------------------------------------------------------------------------

NOP     .equ    0   -- No operation and/or default operation
XFR     .equ    0   -- No operation and/or default operation

--------------------------------------------------------------------------------
--  ALU Operation Field (ALU_Op) Definitions
--------------------------------------------------------------------------------

--  Logic Unit Operations

AND     .equ    1   -- ALU <=  A & M;   N <= ALU[7]; Z <= ~|ALU;
ORA     .equ    2   -- ALU <=  A | M;   N <= ALU[7]; Z <= ~|ALU;
EOR     .equ    3   -- ALU <=  A ^ M;   N <= ALU[7]; Z <= ~|ALU;

BIT     .equ    1   -- ALU <=  A & M;   N <= M[7]; V <= M[6]; Z <= ~|(A & M)
-- BIT #imm         -- ALU <=  A & M;                         Z <= ~|(A & M)
TRB     .equ    0   -- ALU <= ~A & M;                         Z <= ~|(A & M)
TSB     .equ    2   -- ALU <=  A | M;                         Z <= ~|(A & M)

RMB     .equ    0   -- ALU <= ~K & M;  (K <= (1 << bit))
SMB     .equ    2   -- ALU <=  K | M;  (K <= (1 << bit))
BBR     .equ    1   -- ALU <=  K & M;  (K <= (1 << bit))
BBS     .equ    1   -- ALU <=  K & M;  (K <= (1 << bit))

CLC     .equ    0   -- ALU <= ~K & P;   C <= 0; (K <= 0x01)
SEC     .equ    2   -- ALU <=  K | P;   C <= 1; (K <= 0x01)
CLI     .equ    0   -- ALU <= ~K & P;   I <= 0; (K <= 0x04)
SEI     .equ    2   -- ALU <=  K | P;   I <= 1; (K <= 0x04)
CLD     .equ    0   -- ALU <= ~K & P;   D <= 0; (K <= 0x08)
SED     .equ    2   -- ALU <=  K | P;   D <= 1; (K <= 0x08)
CLV     .equ    0   -- ALU <= ~K & P;   V <= 0; (K <= 0x40)

--  Shift Unit Operations (Note: for ASL/LSR, Ci <= 0; for ROL/ROR, Ci <= C)

ASL     .equ    0   -- ALU <= {R[6:0],Ci};N <= ALU[7]; Z <= ~|ALU; C <= R[7]
ROL     .equ    0   -- ALU <= {R[6:0],Ci};N <= ALU[7]; Z <= ~|ALU; C <= R[7]
LSR     .equ    1   -- ALU <= {Ci,R[7:1]};N <= ALU[7]; Z <= ~|ALU; C <= R[0]
ROR     .equ    1   -- ALU <= {Ci,R[7:1]} N <= ALU[7]; Z <= ~|ALU; C <= R[0]

--  Arithmetic Unit Operations

ADC     .equ    0   -- ALU <= Q +  M + C; N <= ALU[7]; Z <= ~|ALU;
--                                        V <= OVF;    C <= COut;
SBC     .equ    1   -- ALU <= Q + ~M + C; N <= ALU[7]; Z <= ~|ALU;
--                                        V <= OVF;    C <= COut;
INC     .equ    0   -- ALU <= Q +  K + 1; N <= ALU[7]; Z <= ~|ALU;
DEC     .equ    1   -- ALU <= Q + ~K + 0; N <= ALU[7]; Z <= ~|ALU;
CMP     .equ    3   -- ALU <= Q + ~M + 1; N <= ALU[7]; Z <= ~|ALU;
--                                                     C <= COut;
ADD     .equ    0   -- ALU <= Q +  M + 0; N <= ALU[7]; Z <= ~|ALU;
--                                                     C <= COut;

--------------------------------------------------------------------------------
--  ALU Left (L/Q) Operand Select
--------------------------------------------------------------------------------

L_M     .equ    0   -- L <= M (default)
L_K     .equ    1   -- L <= K
L_P     .equ    2   -- L <= P
L_A     .equ    3   -- L <= A

Q_M     .equ    0   -- Q <= M (default)
Q_X     .equ    1   -- Q <= X
Q_Y     .equ    2   -- Q <= Y
Q_A     .equ    3   -- Q <= A

--------------------------------------------------------------------------------
--  ALU Right (R) Operand Select
--------------------------------------------------------------------------------

R_M     .equ    0   -- R <= M (default)
R_K     .equ    1   -- R <= K
R_P     .equ    2   -- R <= P
R_A     .equ    3   -- R <= A

--------------------------------------------------------------------------------
--  ALU Carry Input Multiplexer Select
--------------------------------------------------------------------------------

Ci_C    .equ    0   -- Ci <= C (default)
Ci_0    .equ    1   -- Ci <= 0
Ci_1    .equ    2   -- Ci <= 1
Ci_S    .equ    3   -- Ci <= Q[7]

--------------------------------------------------------------------------------
--  ALU Register Write Select Definitions
--------------------------------------------------------------------------------

WS_X    .equ    1   -- Write X (Pre-Index Register)
WS_Y    .equ    2   -- Write Y (Post-Index Register)
WS_A    .equ    3   -- Write Accumulator (Binary)
WS_R    .equ    4   -- Write Registers
WS_S    .equ    5   -- Write S (Stack Pointer)
WS_P    .equ    6   -- Write P (Processor Status Word)
WS_M    .equ    7   -- Write M (ALU Output)

--------------------------------------------------------------------------------
--  ALU Register Output Select Definitions
--------------------------------------------------------------------------------

OS_X    .equ    1   -- ALU <= X
OS_Y    .equ    2   -- ALU <= Y
OS_A    .equ    3   -- ALU <= A
OS_T    .equ    4   -- ALU <= Tmp (Operand Register 2)
OS_S    .equ    5   -- ALU <= S   (Stack Pointer)
OS_P    .equ    6   -- ALU <= P   (Processor Status Word)
OS_M    .equ    7   -- ALU <= M   (Memory Data Input, Operand Register 1)

--------------------------------------------------------------------------------
--  Condition Code Operation/Output Select Definitions
--      Note: CC_Out = 1 if (CCSel == 4'b0000)
--------------------------------------------------------------------------------

TRUE    .equ    0   -- CC_Out <=  1

BRA     .equ    0   -- CC_Out <=  1
--
BCC     .equ    8   -- CC_Out <= ((SIZ) ?   ~C           : ~C); SIZ ? BLOS : BCC
BCS     .equ    9   -- CC_Out <= ((SIZ) ?    C           :  C); SIZ ? BHI  : BCS
BNE     .equ    10  -- CC_Out <= ((SIZ) ?  ~(C | Z)      : ~Z); SIZ ? BLO  : BNE
BEQ     .equ    11  -- CC_Out <= ((SIZ) ?   (C | Z)      :  Z); SIZ ? BHIS : BEQ
--
BVC     .equ    12  -- CC_Out <= ((SIZ) ?  ~(N ^ V)      : ~V); SIZ ? BGE  : BVC
BVS     .equ    13  -- CC_Out <= ((SIZ) ?   (N ^ V)      :  V); SIZ ? BLT  : BVS
BPL     .equ    14  -- CC_OUT <= ((SIZ) ? ~((N ^ V) | Z) : ~N); SIZ ? BGT  : BPL
BMI     .equ    15  -- CC_Out <= ((SIZ) ?  ((N ^ V) | Z) :  N); SIZ ? BLE  : BMI

PSW     .equ    0   -- P <= ALU;
BRK     .equ    1   -- P.4 <= 1 on push P during BRK; Set K on RTI
Z       .equ    2   --                        Z <= ~|(A & M);
NVZ     .equ    3   -- N <= M[7];  V <= M[6]; Z <= ~|(A & M);
PHP     .equ    4   -- P.4 <= 1 on push P during PHP
NZ      .equ    5   -- N <= ALU[7];           Z <= ~|ALU;
NZC     .equ    6   -- N <= ALU[7];           Z <= ~|ALU; C <= COut;
NVZC    .equ    7   -- N <= ALU[7]; V <= OV;  Z <= ~|ALU; C <= COut;

--------------------------------------------------------------------------------
-- Mask Settings
--------------------------------------------------------------------------------

K_0     .equ    1   -- Bit 0
K_1     .equ    2   -- Bit 1
K_2     .equ    4   -- Bit 2
K_3     .equ    8   -- Bit 3
K_4     .equ    16  -- Bit 4
K_5     .equ    32  -- Bit 5
K_6     .equ    64  -- Bit 6
K_7     .equ    128 -- Bit 7

K_C     .equ    1   -- Mask for P.C (Carry Flag)
K_Z     .equ    2   -- Mask for P.Z (Zero Flag)
K_I     .equ    4   -- Mask for P.I (Interrupt Mask)
K_D     .equ    8   -- Mask for P.D (Decimal Mode Flag)
K_B     .equ    16  -- Mask for P.B (BRK/PHP Flag)
K_M     .equ    32  -- Mask for P.M (Unused bit - always 1)
K_V     .equ    64  -- Mask for P.V (oVerflow Flag)
K_N     .equ    128 -- Mask for P.N (Negative Flag)

--------------------------------------------------------------------------------
--
--  Added annotations regarding the implementation of the various opcodes in re-
--  lation to the various microprocessors. As currently defined in this file,
--  the opcodes being decoded represent the instruction set of the original
--  65C02. In other words, the non-NOP instructions are for the W65C02/G65SC02.
--  In the right margin, opcodes that were added by these two processors to the
--  base MOS6502A instruction set are marked with an asterisk (*).
--
--  The instructions added by the Rockwell R65C02 are marked by an addition (+)
--  symbol. The instructions added by WDC from the W65C816/W65C802 processor(s)
--  are marked with an ampersand (&) symbol. The instructions marked by the
--  octothorpe (#) symbol are unique to the M65C02A, and enhance the basic
--  instruction set of the W65C02S. Several of the new M65C02A instructions are
--  inspired by the W65C816 instruction set. However, there are several unique
--  M65C02A instructions, which provide a significant improvement to the base
--  instruction set.
--
--  The new instructions include the PSH zp/abs/imm16, PHR rel16, PUL zp/abs,
--  and stack/base relative instructions from the 8/16-bit W65C816 micropro-
--  cessor. In addition, unique to the M65C02A are a number of prefix instruc-
--  tions that provide indirection to most of the base W65C02S instructions, and
--  increase the size of the operation from 8 bits to 16 bits, and change the
--  default destination register for various instructions. In addition, there
--  are M65C02A-specific instructions to manipulate the M65C02A-specific regis-
--  ter stacks, instructions to implement a DTC/ITC FORTH VM, add support for a
--  CO-Processor interface, and provide block moves.
--
--  The M65C02A instruction set starts with the instruction set of the 6502 ( ),
--  adds the 65C02 (*), adds the Rockwell (+), and the W65C816/W65C802 (&) in-
--  structions. The resulting instruction set is equivalent to the instruction
--  set of the WDC W65C02S microprocessor.
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

_start:     .org    0

--------------------------------------------------------------------------------

    BRK     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,BRK ,0x00  -- 00: BRK #imm
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,BPL ,0x10  -- 10: BPL rel
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,    ,0x20  -- 20: JSR abs
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,BMI ,0x30  -- 30: BMI rel
    SPC1    0,LST,XFR,Q_M,R_M,Ci_C,WS_P,OS_M,BRK ,0x10  -- 40: RTI
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,BVC ,0x50  -- 50: BVC rel
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,    ,0x60  -- 60: RTS
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,BVS ,0x70  -- 70: BVS rel
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,BRA ,0x80  -- 80:*BRA rel
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,BCC ,0x90  -- 90: BCC rel
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_Y,OS_M,NZ  ,0xA0  -- A0: LDY #imm
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,BCS ,0xB0  -- B0: BCS rel
    VAL     0,IDC,CMP,Q_Y,R_M,Ci_1,WS_P,    ,NZC ,0xC0  -- C0: CPY #imm
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,BNE ,0xD0  -- D0: BNE rel
    VAL     0,IDC,CMP,Q_X,R_M,Ci_1,WS_P,    ,NZC ,0xE0  -- E0: CPX #imm
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,BEQ ,0xF0  -- F0: BEQ rel

--------------------------------------------------------------------------------

    VAL     0,LU ,ORA,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x01  -- 01: ORA (zp,X)
    VAL     0,LU ,ORA,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x11  -- 11: ORA (zp),Y
    VAL     0,LU ,AND,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x21  -- 21: ANL (zp,X)
    VAL     0,LU ,AND,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x31  -- 31: ANL (zp),Y
    VAL     0,LU ,EOR,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x41  -- 41: EOR (zp,X)
    VAL     0,LU ,EOR,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x51  -- 51: EOR (zp),Y
    VAL     0,ADD,ADC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0x61  -- 61: ADC (zp,X)
    VAL     0,ADD,ADC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0x71  -- 71: ADC (zp),Y
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_A,    ,0x81  -- 81: STA (zp,X)
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_A,    ,0x91  -- 91: STA (zp),Y
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_A,OS_M,NZ  ,0xA1  -- A1: LDA (zp,X)
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_A,OS_M,NZ  ,0xB1  -- B1: LDA (zp),Y
    VAL     0,IDC,CMP,Q_A,R_M,Ci_1,WS_P,    ,NZC ,0xC1  -- C1: CMP (zp,X)
    VAL     0,IDC,CMP,Q_A,R_M,Ci_1,WS_P,    ,NZC ,0xD1  -- D1: CMP (zp),Y
    VAL     0,ADD,SBC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0xE1  -- E1: SBC (zp,X)
    VAL     0,ADD,SBC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0xF1  -- F1: SBC (zp),Y

--------------------------------------------------------------------------------

    COP     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_M,    ,0x02  -- 02:#COP #imm
    VAL     0,LU ,ORA,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x12  -- 12:*ORA (zp)
    VAL     0,   ,   ,   ,   ,    ,    ,    ,    ,0x22  -- 22:#NOP
    VAL     0,LU ,AND,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x32  -- 32:*ANL (zp)
    VAL     0,   ,   ,   ,   ,    ,    ,    ,    ,0x42  -- 42:#NOP
    VAL     0,LU ,EOR,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x52  -- 52:*EOR (zp)
    VAL     0,   ,   ,   ,   ,    ,    ,    ,    ,0x62  -- 62:#NOP
    VAL     0,ADD,ADC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0x72  -- 72:*ADC (zp)
    VAL     0,   ,   ,   ,   ,    ,    ,    ,    ,0x82  -- 82:#NOP
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_A,    ,0x92  -- 92:*STA (zp)
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_X,OS_M,NZ  ,0xA2  -- A2: LDX #imm
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_A,OS_M,NZ  ,0xB2  -- B2:*LDA (zp)
    SPC2    0,ADD,ADC,Q_X,R_M,Ci_0,WS_S,    ,    ,0x80  -- C2:#ADJ #imm
    VAL     0,IDC,CMP,Q_A,R_M,Ci_1,WS_P,    ,NZC ,0xD2  -- D2:*CMP (zp)
    SPC1    0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_M,    ,0x80  -- E2:#PSH #imm
    VAL     0,ADD,SBC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0xF2  -- F2:*SBC (zp)

--------------------------------------------------------------------------------

    VAL     0,LU ,ORA,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x03  -- 03:#ORA ip,I++
    VAL     1,SU ,ASL,Q_M,R_M,Ci_0,WS_P,    ,NZC ,0x13  -- 13:#ASL ip,I++
    VAL     0,LU ,AND,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x23  -- 23:#ANL ip,I++
    VAL     1,SU ,ROL,Q_M,R_M,Ci_C,WS_P,    ,NZC ,0x33  -- 33:#ROL ip,I++
    VAL     0,LU ,EOR,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x43  -- 43:#EOR ip,I++
    VAL     1,SU ,LSR,Q_M,R_M,Ci_0,WS_P,    ,NZC ,0x53  -- 53:#LSR ip,I++
    VAL     0,ADD,ADC,Q_A,R_M,Ci_0,WS_A,    ,NVZC,0x63  -- 63:#ADD ip,I++
    VAL     1,SU ,ROR,Q_M,R_M,Ci_C,WS_P,    ,NZC ,0x73  -- 73:#ROR ip,I++
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_A,    ,0x83  -- 83:#STA ip,I++
    VAL     1,LU ,TSB,L_A,R_M,Ci_C,WS_P,    ,Z   ,0x93  -- 93:#TSB ip,I++
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_A,OS_M,NZ  ,0xA3  -- A3:#LDA ip,I++
    VAL     1,LU ,TRB,L_A,R_M,Ci_C,WS_P,    ,Z   ,0xB3  -- B3:#TRB ip,I++
    VAL     0,IDC,CMP,Q_A,R_M,Ci_1,WS_P,    ,NZC ,0xC3  -- C3:#CMP ip,I++
    VAL     1,IDC,DEC,Q_M,R_K,Ci_0,WS_P,    ,NZ  ,0x00  -- D3:#DEC ip,I++
    VAL     0,ADD,SBC,Q_A,R_M,Ci_1,WS_A,    ,NVZC,0xE3  -- E3:#SUB ip,I++
    VAL     1,IDC,INC,Q_M,R_K,Ci_1,WS_P,    ,NZ  ,0x00  -- F3:#INC ip,I++

--------------------------------------------------------------------------------

    VAL     1,LU ,TSB,L_A,R_M,Ci_C,WS_P,    ,Z   ,0x04  -- 04:*TSB zp
    VAL     1,LU ,TRB,L_A,R_M,Ci_C,WS_P,    ,Z   ,0x14  -- 14:*TRB zp
    VAL     0,LU ,BIT,L_A,R_M,Ci_C,WS_P,    ,NVZ ,0x24  -- 24: BIT zp
    VAL     0,LU ,BIT,L_A,R_M,Ci_C,WS_P,    ,NVZ ,0x34  -- 34:*BIT zp,X
    VAL     0,LST,XFR,Q_A,R_M,Ci_C,    ,OS_A,    ,0x44  -- 44:#XMA sp,S
    SPC1    0,   ,   ,   ,   ,    ,    ,    ,    ,0x20  -- 54:#MOV #imm
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,    ,0x64  -- 64:*STZ zp
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,    ,0x74  -- 74:*STZ zp,X
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_Y,    ,0x84  -- 84: STY zp
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_Y,    ,0x94  -- 94: STY zp,X
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_Y,OS_M,NZ  ,0xA4  -- A4: LDY zp
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_Y,OS_M,NZ  ,0xB4  -- B4: LDY zp,X
    VAL     0,IDC,CMP,Q_Y,R_M,Ci_1,WS_P,    ,NZC ,0xC4  -- C4: CPY zp
    SPC1    0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_M,    ,0x80  -- D4:#PSH zp
    VAL     0,IDC,CMP,Q_X,R_M,Ci_1,WS_P,    ,NZC ,0xE4  -- E4: CPX zp
    SPC1    0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_M,NZ  ,0x00  -- F4:#PUL zp

--------------------------------------------------------------------------------

    VAL     0,LU ,ORA,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x05  -- 05: ORA zp
    VAL     0,LU ,ORA,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x15  -- 15: ORA zp,X
    VAL     0,LU ,AND,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x25  -- 25: ANL zp
    VAL     0,LU ,AND,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x35  -- 35: ANL zp,X
    VAL     0,LU ,EOR,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x45  -- 45: EOR zp
    VAL     0,LU ,EOR,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x55  -- 55: EOR zp,X
    VAL     0,ADD,ADC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0x65  -- 65: ADC zp
    VAL     0,ADD,ADC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0x75  -- 75: ADC zp,X
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_A,    ,0x85  -- 85: STA zp
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_A,    ,0x95  -- 95: STA zp,X
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_A,OS_M,NZ  ,0xA5  -- A5: LDA zp
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_A,OS_M,NZ  ,0xB5  -- B5: LDA zp,X
    VAL     0,IDC,CMP,Q_A,R_M,Ci_1,WS_P,    ,NZC ,0xC5  -- C5: CMP zp
    VAL     0,IDC,CMP,Q_A,R_M,Ci_1,WS_P,    ,NZC ,0xD5  -- D5: CMP zp,X
    VAL     0,ADD,SBC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0xE5  -- E5: SBC zp
    VAL     0,ADD,SBC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0xF5  -- F5: SBC zp,X

--------------------------------------------------------------------------------

    VAL     1,SU ,ASL,Q_M,R_M,Ci_0,WS_P,    ,NZC ,0x06  -- 06: ASL zp
    VAL     1,SU ,ASL,Q_M,R_M,Ci_0,WS_P,    ,NZC ,0x16  -- 16: ASL zp,X
    VAL     1,SU ,ROL,Q_M,R_M,Ci_C,WS_P,    ,NZC ,0x26  -- 26: ROL zp
    VAL     1,SU ,ROL,Q_M,R_M,Ci_C,WS_P,    ,NZC ,0x36  -- 36: ROL zp,X
    VAL     1,SU ,LSR,Q_M,R_M,Ci_0,WS_P,    ,NZC ,0x46  -- 46: LSR zp
    VAL     1,SU ,LSR,Q_M,R_M,Ci_0,WS_P,    ,NZC ,0x56  -- 56: LSR zp,X
    VAL     1,SU ,ROR,Q_M,R_M,Ci_C,WS_P,    ,NZC ,0x66  -- 66: ROR zp
    VAL     1,SU ,ROR,Q_M,R_M,Ci_C,WS_P,    ,NZC ,0x76  -- 76: ROR zp,X
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_X,    ,0x86  -- 86: STX zp
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_X,    ,0x96  -- 96: STX zp,Y
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_X,OS_M,NZ  ,0xA6  -- A6: LDX zp
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_X,OS_M,NZ  ,0xB6  -- B6: LDX zp,Y
    VAL     1,IDC,DEC,Q_M,R_K,Ci_0,WS_P,    ,NZ  ,0x00  -- C6: DEC zp
    VAL     1,IDC,DEC,Q_M,R_K,Ci_0,WS_P,    ,NZ  ,0x00  -- D6: DEC zp,X
    VAL     1,IDC,INC,Q_M,R_K,Ci_1,WS_P,    ,NZ  ,0x00  -- E6: INC zp
    VAL     1,IDC,INC,Q_M,R_K,Ci_1,WS_P,    ,NZ  ,0x00  -- F6: INC zp,X

--------------------------------------------------------------------------------

    VAL     1,LU ,RMB,L_K,R_M,Ci_C,    ,    ,    ,K_0   -- 07:+RMB0 dp
    VAL     1,LU ,RMB,L_K,R_M,Ci_C,    ,    ,    ,K_1   -- 17:+RMB1 dp
    VAL     1,LU ,RMB,L_K,R_M,Ci_C,    ,    ,    ,K_2   -- 27:+RMB2 dp
    VAL     1,LU ,RMB,L_K,R_M,Ci_C,    ,    ,    ,K_3   -- 37:+RMB3 dp
    VAL     1,LU ,RMB,L_K,R_M,Ci_C,    ,    ,    ,K_4   -- 47:+RMB4 dp
    VAL     1,LU ,RMB,L_K,R_M,Ci_C,    ,    ,    ,K_5   -- 57:+RMB5 dp
    VAL     1,LU ,RMB,L_K,R_M,Ci_C,    ,    ,    ,K_6   -- 67:+RMB6 dp
    VAL     1,LU ,RMB,L_K,R_M,Ci_C,    ,    ,    ,K_7   -- 77:+RMB7 dp
    VAL     1,LU ,SMB,L_K,R_M,Ci_C,    ,    ,    ,K_0   -- 87:+SMB0 dp
    VAL     1,LU ,SMB,L_K,R_M,Ci_C,    ,    ,    ,K_1   -- 97:+SMB1 dp
    VAL     1,LU ,SMB,L_K,R_M,Ci_C,    ,    ,    ,K_2   -- A7:+SMB2 dp
    VAL     1,LU ,SMB,L_K,R_M,Ci_C,    ,    ,    ,K_3   -- B7:+SMB3 dp
    VAL     1,LU ,SMB,L_K,R_M,Ci_C,    ,    ,    ,K_4   -- C7:+SMB4 dp
    VAL     1,LU ,SMB,L_K,R_M,Ci_C,    ,    ,    ,K_5   -- D7:+SMB5 dp
    VAL     1,LU ,SMB,L_K,R_M,Ci_C,    ,    ,    ,K_6   -- E7:+SMB6 dp
    VAL     1,LU ,SMB,L_K,R_M,Ci_C,    ,    ,    ,K_7   -- F7:+SMB7 dp

--------------------------------------------------------------------------------

    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_P,PHP ,0x08  -- 08: PHP
    VAL     0,LU ,CLC,L_K,R_P,Ci_C,WS_P,    ,PSW ,K_C   -- 18: CLC
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_P,OS_M,PSW ,0x28  -- 28: PLP
    VAL     0,LU ,SEC,L_K,R_P,Ci_C,WS_P,    ,PSW ,K_C   -- 38: SEC
    SPC1    0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_A,    ,0x80  -- 48: PHA
    VAL     0,LU ,CLI,L_K,R_P,Ci_C,WS_P,    ,PSW ,K_I   -- 58: CLI
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_A,OS_M,NZ  ,0x68  -- 68: PLA
    VAL     0,LU ,SEI,L_K,R_P,Ci_C,WS_P,    ,PSW ,K_I   -- 78: SEI
    VAL     0,IDC,DEC,Q_Y,R_K,Ci_0,WS_Y,    ,NZ  ,0x00  -- 88: DEY
    VAL     0,LST,XFR,Q_A,R_M,Ci_C,WS_A,OS_Y,NZ  ,0x98  -- 98: TYA
    VAL     0,LST,XFR,Q_A,R_M,Ci_C,WS_Y,OS_A,NZ  ,0xA8  -- A8: TAY
    VAL     0,LU ,CLV,L_K,R_P,Ci_C,WS_P,    ,PSW ,K_V   -- B8: CLV
    VAL     0,IDC,INC,Q_Y,R_K,Ci_1,WS_Y,    ,NZ  ,0x00  -- C8: INY
    VAL     0,LU ,CLD,L_K,R_P,Ci_C,WS_P,    ,PSW ,K_D   -- D8: CLD
    VAL     0,IDC,INC,Q_X,R_K,Ci_1,WS_X,    ,NZ  ,0x00  -- E8: INX
    VAL     0,LU ,SED,L_K,R_P,Ci_C,WS_P,    ,PSW ,K_D   -- F8: SED

--------------------------------------------------------------------------------

    VAL     0,LU ,ORA,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x09  -- 09: ORA #imm
    VAL     0,LU ,ORA,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x19  -- 19: ORA abs,Y
    VAL     0,LU ,AND,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x29  -- 29: ANL #imm
    VAL     0,LU ,AND,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x39  -- 39: ANL abs,Y
    VAL     0,LU ,EOR,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x49  -- 49: EOR #imm
    VAL     0,LU ,EOR,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x59  -- 59: EOR abs,Y
    VAL     0,ADD,ADC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0x69  -- 69: ADC #imm
    VAL     0,ADD,ADC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0x79  -- 79: ADC abs,Y
    VAL     0,LU ,BIT,L_A,R_M,Ci_C,WS_P,    ,Z   ,0x89  -- 89:*BIT #imm
    VAL     0,LST,XFR,Q_A,R_M,Ci_C,    ,OS_A,    ,0x99  -- 99: STA abs,Y
    VAL     0,LST,XFR,Q_A,R_M,Ci_C,WS_A,OS_M,NZ  ,0xA9  -- A9: LDA #imm
    VAL     0,LST,XFR,Q_A,R_M,Ci_C,WS_A,OS_M,NZ  ,0xB9  -- B9: LDA abs,Y
    VAL     0,IDC,CMP,Q_A,R_M,Ci_1,WS_P,    ,NZC ,0xC9  -- C9: CMP #imm
    VAL     0,IDC,CMP,Q_A,R_M,Ci_1,WS_P,    ,NZC ,0xD9  -- D9: CMP abs,Y
    VAL     0,ADD,SBC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0xE9  -- E9: SBC #imm
    VAL     0,ADD,SBC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0xF9  -- F9: SBC abs,Y

--------------------------------------------------------------------------------

    SPC2    0,SU ,ASL,Q_A,R_M,Ci_0,WS_A,    ,NZC ,0x0A  -- 0A: ASL A
    SPC2    0,IDC,INC,Q_A,R_K,Ci_1,WS_A,    ,NZ  ,0x00  -- 1A:*INC A
    SPC2    0,SU ,ROL,Q_A,R_M,Ci_C,WS_A,    ,NZC ,0x2A  -- 2A: ROL A
    SPC2    0,IDC,DEC,Q_A,R_K,Ci_0,WS_A,    ,NZ  ,0x00  -- 3A:*DEC A
    SPC2    0,SU ,LSR,Q_A,R_M,Ci_0,WS_A,    ,NZC ,0x04  -- 4A: LSR A
    SPC1    0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_Y,    ,0x80  -- 5A:*PHY
    VAL     0,SU ,ROR,Q_A,R_M,Ci_C,WS_A,    ,NZC ,0x6A  -- 6A: ROR A
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_Y,OS_M,NZ  ,0x7A  -- 7A:*PLY
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_A,OS_X,NZ  ,0x8A  -- 8A: TXA
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_S,OS_X,    ,0x9A  -- 9A: TXS
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_X,OS_A,NZ  ,0xAA  -- AA: TAX
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_X,OS_S,NZ  ,0xBA  -- BA: TSX
    VAL     0,IDC,DEC,Q_X,R_K,Ci_0,WS_X,    ,NZ  ,0x00  -- CA: DEX
    SPC1    0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_X,    ,0x80  -- DA:*PHX
    VAL     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0xEA  -- EA: NOP
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_X,OS_M,NZ  ,0xFA  -- FA:*PLX

--------------------------------------------------------------------------------
-- 0B...BB: 1 byte, 1 cycle
    SPC1    0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x08  -- 0B:#DUP  -- DUP
    SPC1    0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x04  -- 1B:#SWP  -- SWP/XCH
    SPC1    0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x02  -- 2B:#ROT  -- ROT
    FTH     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x80  -- 3B:#NXT  -- NeXT
    FTH     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_T,    ,0x28  -- 4B:#PHI  -- Psh IP/W
    FTH     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x01  -- 5B:#INI  -- Inc IP/W
    FTH     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x18  -- 6B:#PLI  -- Pop IP/W
    FTH     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_T,    ,0x48  -- 7B:#ENT  -- ENTer
    PFX     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x10  -- 8B:#OSX  -- S <=> X
    PFX     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x01  -- 9B:#IND  -- IND
    PFX     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x02  -- AB:#SIZ  -- SIZ
    PFX     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x03  -- BB:#ISZ  -- IND + SIZ
    PFX     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x12  -- CB:#OSZ  -- OSX + SIZ
    PFX     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x13  -- DB:#OIS  -- OSX + ISZ
    PFX     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x04  -- EB:#OAX  -- A <=> X
    PFX     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x08  -- FB:#OAY  -- A <=> Y

--------------------------------------------------------------------------------

    VAL     1,LU ,TSB,L_A,R_M,Ci_C,WS_P,    ,Z   ,0x0C  -- 0C:*TSB abs
    VAL     1,LU ,TRB,L_A,R_M,Ci_C,WS_P,    ,Z   ,0x1C  -- 1C:*TRB abs
    VAL     0,LU ,BIT,L_A,R_M,Ci_C,WS_P,    ,NVZ ,0x2C  -- 2C: BIT abs
    VAL     0,LU ,BIT,L_A,R_M,Ci_C,WS_P,    ,NVZ ,0x3C  -- 3C:*BIT abs,X
    VAL     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x4C  -- 4C: JMP abs
    SPC1    0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x40  -- 5C:#PHR rel16
    VAL     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x6C  -- 6C: JMP (abs)
    VAL     0,NOP,NOP,Q_M,R_M,Ci_C,    ,    ,    ,0x7C  -- 7C:*JMP (abs,X)
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_Y,    ,0x8C  -- 8C: STY abs
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,    ,0x9C  -- 9C:*STZ abs
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_Y,OS_M,NZ  ,0xAC  -- AC: LDY abs
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_Y,OS_M,NZ  ,0xBC  -- BC: LDY abs,X
    VAL     0,IDC,CMP,Q_Y,R_M,Ci_1,WS_P,    ,NZC ,0xCC  -- CC: CPY abs
    SPC1    0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_M,    ,0x80  -- DC:#PSH abs
    VAL     0,IDC,CMP,Q_X,R_M,Ci_1,WS_P,    ,NZC ,0xEC  -- EC: CPX abs
    SPC1    0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_M,NZ  ,0x00  -- FC:#PUL abs

--------------------------------------------------------------------------------

    VAL     0,LU ,ORA,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x0D  -- 0D: ORA abs
    VAL     0,LU ,ORA,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x1D  -- 1D: ORA abs,X
    VAL     0,LU ,AND,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x2D  -- 2D: ANL abs
    VAL     0,LU ,AND,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x3D  -- 3D: ANL abs,X
    VAL     0,LU ,EOR,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x4D  -- 4D: EOR abs
    VAL     0,LU ,EOR,L_A,R_M,Ci_C,WS_A,    ,NZ  ,0x5D  -- 5D: EOR abs,X
    VAL     0,ADD,ADC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0x6D  -- 6D: ADC abs
    VAL     0,ADD,ADC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0x7D  -- 7D: ADC abs,X
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_A,    ,0x8D  -- 8D: STA abs
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_A,    ,0x9D  -- 9D: STA abs,X
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_A,OS_M,NZ  ,0xAD  -- AD: LDA abs
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_A,OS_M,NZ  ,0xBD  -- BD: LDA abs,X
    VAL     0,IDC,CMP,Q_A,R_M,Ci_1,WS_P,    ,NZC ,0xCD  -- CD: CMP abs
    VAL     0,IDC,CMP,Q_A,R_M,Ci_1,WS_P,    ,NZC ,0xDD  -- DD: CMP abs,X
    VAL     0,ADD,SBC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0xED  -- ED: SBC abs
    VAL     0,ADD,SBC,Q_A,R_M,Ci_C,WS_A,    ,NVZC,0xFD  -- FD: SBC abs,X

--------------------------------------------------------------------------------

    VAL     1,SU ,ASL,Q_M,R_M,Ci_0,WS_P,    ,NZC ,0x0E  -- 0E: ASL abs
    VAL     1,SU ,ASL,Q_M,R_M,Ci_0,WS_P,    ,NZC ,0x1E  -- 1E: ASL abs,X
    VAL     1,SU ,ROL,Q_M,R_M,Ci_C,WS_P,    ,NZC ,0x2E  -- 2E: ROL abs
    VAL     1,SU ,ROL,Q_M,R_M,Ci_C,WS_P,    ,NZC ,0x3E  -- 3E: ROL abs,X
    VAL     1,SU ,LSR,Q_M,R_M,Ci_0,WS_P,    ,NZC ,0x4E  -- 4E: LSR abs
    VAL     1,SU ,LSR,Q_M,R_M,Ci_0,WS_P,    ,NZC ,0x5E  -- 5E: LSR abs,X
    VAL     1,SU ,ROR,Q_M,R_M,Ci_C,WS_P,    ,NZC ,0x6E  -- 6E: ROR abs
    VAL     1,SU ,ROR,Q_M,R_M,Ci_C,WS_P,    ,NZC ,0x7E  -- 7E: ROR abs,X
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,OS_X,    ,0x8E  -- 8E: STX abs
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,    ,    ,    ,0x9E  -- 9E:*STZ abs,X
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_X,OS_M,NZ  ,0xAE  -- AE: LDX abs
    VAL     0,LST,XFR,Q_M,R_M,Ci_C,WS_X,OS_M,NZ  ,0xBE  -- BE: LDX abs,Y
    VAL     1,IDC,DEC,Q_M,R_K,Ci_0,WS_P,    ,NZ  ,0x00  -- CE: DEC abs
    VAL     1,IDC,DEC,Q_M,R_K,Ci_0,WS_P,    ,NZ  ,0x00  -- DE: DEC abs,X
    VAL     1,IDC,INC,Q_M,R_K,Ci_1,WS_P,    ,NZ  ,0x00  -- EE: INC abs
    VAL     1,IDC,INC,Q_M,R_K,Ci_1,WS_P,    ,NZ  ,0x00  -- FE: INC abs,X

--------------------------------------------------------------------------------

    VAL     0,LU ,BBR,L_K,R_M,Ci_C,    ,    ,BEQ ,K_0   -- 0F:+BBR0 zp,rel
    VAL     0,LU ,BBR,L_K,R_M,Ci_C,    ,    ,BEQ ,K_1   -- 1F:+BBR1 zp,rel
    VAL     0,LU ,BBR,L_K,R_M,Ci_C,    ,    ,BEQ ,K_2   -- 2F:+BBR2 zp,rel
    VAL     0,LU ,BBR,L_K,R_M,Ci_C,    ,    ,BEQ ,K_3   -- 3F:+BBR3 zp,rel
    VAL     0,LU ,BBR,L_K,R_M,Ci_C,    ,    ,BEQ ,K_4   -- 4F:+BBR4 zp,rel
    VAL     0,LU ,BBR,L_K,R_M,Ci_C,    ,    ,BEQ ,K_5   -- 5F:+BBR5 zp,rel
    VAL     0,LU ,BBR,L_K,R_M,Ci_C,    ,    ,BEQ ,K_6   -- 6F:+BBR6 zp,rel
    VAL     0,LU ,BBR,L_K,R_M,Ci_C,    ,    ,BEQ ,K_7   -- 7F:+BBR7 zp,rel
    VAL     0,LU ,BBS,L_K,R_M,Ci_C,    ,    ,BNE ,K_0   -- 8F:+BBS0 zp,rel
    VAL     0,LU ,BBS,L_K,R_M,Ci_C,    ,    ,BNE ,K_1   -- 9F:+BBS1 zp,rel
    VAL     0,LU ,BBS,L_K,R_M,Ci_C,    ,    ,BNE ,K_2   -- AF:+BBS2 zp,rel
    VAL     0,LU ,BBS,L_K,R_M,Ci_C,    ,    ,BNE ,K_3   -- BF:+BBS3 zp,rel
    VAL     0,LU ,BBS,L_K,R_M,Ci_C,    ,    ,BNE ,K_4   -- CF:+BBS4 zp,rel
    VAL     0,LU ,BBS,L_K,R_M,Ci_C,    ,    ,BNE ,K_5   -- DF:+BBS5 zp,rel
    VAL     0,LU ,BBS,L_K,R_M,Ci_C,    ,    ,BNE ,K_6   -- EF:+BBS6 zp,rel
    VAL     0,LU ,BBS,L_K,R_M,Ci_C,    ,    ,BNE ,K_7   -- FF:+BBS7 zp,rel

--------------------------------------------------------------------------------

_end:
